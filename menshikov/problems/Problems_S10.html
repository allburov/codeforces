<html>
<head>
 <title>Тренировка S10</title>
 <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
 <meta name="Author" content="Fyodor Menshikov, Vologda, Russia">
 <meta name="E-mail" content="mfv@mail.ru">
 <meta name="Homepage" content="http://www.uni-vologda.ac.ru/~mfv/">
</head>
<body bgcolor=white text=black>

<center><font size=+3>Тренировка S10</font></center><br>

<font size=-1>
Время тестирования приведено для Intel Celeron 400.<br>
Решения должны быть представлены на Turbo Pascal 7.0.
Объём памяти, предоставляемый программе, составляет 500 кб.
</font><br>

<a name="antiqs">
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=+1>
Задача A. Анти-QuickSort</font><br><br>
Для сортировки последовательности чисел широко используется быстрая сортировка
- QuickSort. Далее приведена программа, которая сортирует массив <code>a</code>,
используя этот алгоритм.
<pre>
<b>var</b>
   a : <b>array</b> [1..N] <b>of</b> integer;

   <b>procedure</b> QSort(left, right : integer);
   <b>var</b>
      i, j : integer;
      key : integer;
      buf : integer;
   <b>begin</b>
      key := a[(left + right) <b>div</b> 2];
      i := left;
      j := right;
      <b>repeat</b>
         <b>while</b> a[i] &lt; key <b>do</b>    {первый while}
            inc(i); 
         <b>while</b> key &lt; a[j] <b>do</b>    {второй while}
            dec(j); 
         <b>if</b> i &lt;= j <b>then</b> <b>begin</b>
            buf := a[i];
            a[i] := a[j];
            a[j] := buf;
            inc(i);
            dec(j);
         <b>end</b>;
      <b>until</b> i &gt; j;

      <b>if</b> left &lt; j <b>then</b>
         QSort(left, j);
      <b>if</b> i &lt; right <b>then</b>
         QSort(i, right);
   <b>end</b>;

<b>begin</b>
   ...
   QSort(1, N);
<b>end</b>.
</pre>
Хотя QuickSort является самой быстрой сортировкой в среднем, существуют тесты,
на которых она работает очень долго. Оценивать время работы алгоритма будем
количеством сравнений с элементами массива (то&nbsp;есть суммарным количеством
сравнений в первом и втором <code><b>while</b></code>). Требуется написать
программу, генерирующую тест, на котором быстрая сортировка сделает наибольшее
число таких сравнений.
<br>
<b>Ввод</b> из файла antiqs.in. В первой строке находится единственное число
<i>N</i>.<br>
<b>Ограничения:</b> 1&nbsp;&lt;=&nbsp;<i>N</i>&nbsp;&lt;=&nbsp;70&nbsp;000,
время&nbsp;1&nbsp;с.<br>
<b>Вывод</b> в файл antiqs.out. Вывести перестановку чисел от 1 до <i>N</i>,
на которой быстрая сортировка выполнит максимальное число сравнений. Если таких
перестановок несколько, вывести любую из них.<br>
<b>Примеры</b>
<pre><b>Ввод 1</b>
3
<b>Вывод 1</b>
1 3 2
</pre>

<a name="fibostr">
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=+1>
Задача B. Строки Фибоначчи</font><br><br>
Строку Фибоначчи <i>F</i>(<i>K</i>) для натуральных чисел <i>K</i> определим
так:
<i>F</i>(1)&nbsp;=&nbsp;<code>'A'</code>,
<i>F</i>(2)&nbsp;=&nbsp;<code>'B'</code>,
<i>F</i>(<i>K</i>)&nbsp;=&nbsp;<i>F</i>(<i>K</i>&nbsp;-&nbsp;1)&nbsp;+&nbsp;<i>F</i>(<i>K</i>&nbsp;-&nbsp;2)
при <i>K</i>&nbsp;&gt;&nbsp;2, где "+" означает конкатенацию строк. Требуется
найти количество вхождений строки <i>S</i>, состоящей из символов
<code>A</code> и <code>B</code>, в строку Фибоначчи <i>F</i>(<i>N</i>).<br>
<b>Ограничения:</b> длина <i>S</i> от 1 до 25,
1&nbsp;&lt;=&nbsp;<i>N</i>&nbsp;&lt;=&nbsp;45, время&nbsp;1&nbsp;с.<br>
<u>Примечание.</u> Длина <i>F</i>(45) равна 1&nbsp;134&nbsp;903&nbsp;170.<br>
<b>Ввод</b> из файла fibostr.in. В первой строке содержится число <i>N</i>,
во второй - строка <i>S</i>.
<br>
<b>Вывод</b> в файл fibostr.out. Выводится одно число - количество вхождений
строки <i>S</i> в строку Фибоначчи <i>F</i>(<i>N</i>).<br>
<b>Примеры</b>
<pre><b>Ввод 1</b>    <b>Ввод 2</b>    <b>Ввод 3</b>     <b>Ввод 4</b>
1         2         8          35
A         ABA       BBABAB     BBABAB
<b>Вывод 1</b>   <b>Вывод 2</b>   <b>Вывод 3</b>    <b>Вывод 4</b>
1         0         3          1346268
</pre>

<a name="crossgam">
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=+1>
Задача C. Игра в зачёркивание</font><br><br>
Бумажная полоска разделена на <i>N</i> клеток. Двое играющих по очереди
выбирают и зачёркивают ровно <i>K</i> пустых смежных клеток. Выигрывает
сделавший последний ход. Оба игрока придерживаются правильной стратегии.
Дана ситуация игры. Требуется определить, кто выиграет.<br>
<b>Ограничения:</b>
1&nbsp;&lt;=&nbsp;<i>K</i>&nbsp;&lt;=&nbsp;<i>N</i>&nbsp;&lt;=&nbsp;40,
время&nbsp;10&nbsp;с.<br>
<b>Ввод</b> из файла crossgam.in. В первой строке содержатся числа <i>N</i> и
<i>K</i>, во второй строке <i>N</i> символов: латинская заглавная
<code>O</code> - пустая клетка, латинская заглавная <code>X</code> -
зачёркнутая клетка.<br>
<b>Вывод</b> в файл crossgam.out. Вывести одно число: <code>1</code>, если
выиграет первый, сделавший ход; <code>2</code>, если выиграет второй;
<code>0</code>, если ход сделать нельзя.<br>
<b>Примеры</b>
<pre><b>Ввод 1</b>    <b>Ввод 2</b>    <b>Ввод 3</b>
4 2       5 2       7 2
OOOO      OOOOO     OXXOXXO
<b>Вывод 1</b>   <b>Вывод 2</b>   <b>Вывод 3</b>
1         2         0
</pre>

<a name="border">
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=+1>
Задача D. Граница многоугольника</font><br><br>
Многоугольник на плоскости задан целочисленными координатами своих <i>N</i>
вершин в декартовой системе координат. Требуется найти количество точек
с целочисленными координатами, лежащих на границе многоугольника. Стороны
многоугольника друг с другом не соприкасаются (за исключением соседних -
в вершинах) и не пересекаются.<br>
<b>Ограничения:</b> 3&nbsp;&lt;=&nbsp;<i>N</i>&nbsp;&lt;=&nbsp;100&nbsp;000,
координаты вершин целые и по модулю не превосходят
1&nbsp;000&nbsp;000&nbsp;000, время&nbsp;2&nbsp;с.<br> 
<b>Ввод</b> из файла border.in. В первой строке содержится число <i>N</i>,
в следующих <i>N</i> строках - пары чисел - координаты точек. Если соединить
точки в данном порядке, а также соединить первую и последнюю точки, получится
заданный многоугольник.<br>
<b>Вывод</b> в файл border.out. Вывести одно число - количество точек
с целочисленными координатами на границе многоугольника.<br>
<b>Примеры</b>
<pre><b>Ввод 1</b>
3
10 0
0 10
0 0
<b>Вывод 1</b>
30
</pre>

<a name="speleo">
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=+1>
Задача E. Путь спелеолога</font><br><br>
Пещера представлена кубом, разбитым на <i>N</i> частей по каждому измерению
(то&nbsp;есть на <i>N</i><sup> 3</sup> кубических клеток). Каждая клетка может
быть или пустой, или полностью заполненной камнем. Исходя из положения
спелеолога в пещере, требуется найти, какое минимальное количество перемещений
по клеткам ему требуется, чтобы выбраться на поверхность. Переходить из клетки
в клетку можно, только если они обе свободны и имеют общую грань.<br>
<b>Ограничения:</b> 1&nbsp;&lt;=&nbsp;<i>N</i>&nbsp;&lt;=&nbsp;30,
время&nbsp;1&nbsp;с.<br>
<b>Ввод</b> из файла speleo.in. В первой строке содержится число <i>N</i>.
Далее следует <i>N</i> блоков. Блок состоит из пустой строки и <i>N</i> строк
по <i>N</i> символов: <code>#</code> - обозначает клетку, заполненную камнями,
точка - свободную клетку. Начальное положение спелеолога обозначено заглавной
буквой <code>S</code>. Первый блок представляет верхний уровень пещеры,
достижение любой свободной его клетки означает выход на поверхность. Выход
на поверхность всегда возможен.<br>
<b>Вывод</b> в файл speleo.out. Вывести одно число - длину пути
до поверхности.<br>
<b>Примеры</b>
<pre><b>Ввод 1</b>
3

###
###
.##

.#.
.#S
.#.

###
...
###
<b>Вывод 1</b>
6
<b>Комментарий 1</b>
Нужно спуститься на уровень вниз,
сделать два движения на запад,
подняться на уровень вверх,
сделать движение на юг,
подняться на уровень вверх.
</pre>

<a name="holey">
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=+1>
Задача F. Дырявая ткань</font><br><br>
На столе лежат несколько кусков ткани, не перекрывая друг друга. Эти куски
могут иметь дыры, в том числе и настолько большие, что в них может поместиться
целый кусок ткани. Был получен чёрно-белый образ поверхности стола, на котором
области, покрытые тканью, представлены символами <code>*</code>, а свободные
площади - точками. Один кусок ткани, таким образом, представлен 4-связной
областью символов <code>*</code>, то&nbsp;есть группой
<code>*</code>, соседствующих друг с другом горизонтально или вертикально,
но не по диагонали.
<pre>
.***..***
.*.*.**.*
.***.*.**
*...**.*.
</pre>
На схеме три куска - один без дыр, а два - с одной дырой каждый: первый
площадью 8, второй - площадью 12.
<br><br>
Ваша цель - найти кусок с наибольшим количеством дыр в нём. Дыра - это
4-связная область точек, полностью окружённых символами <code>*</code>.
Если несколько кусков имеют одинаковое количество дыр, нужно выбрать кусок
минимальной площади.
<br><br>
<b>Ввод</b> из файла holey.in. В первой строке содержатся два числа <i>W</i> и
<i>H</i>, разделённые пробелами. Следующие <i>H</i> строк содержат по <i>W</i>
символов каждая. Символы в этих строках - или <code>*</code> (ASCII 42), или
точка (ASCII 46).
<br><br>
<b>Ограничения:</b>
1&nbsp;&lt;=&nbsp;<i>W</i>,&nbsp;<i>H</i>&nbsp;&lt;=&nbsp;100,
время&nbsp;1&nbsp;с.
<br><br>
<b>Вывод</b> в файл holey.out. Вывести одно целое число - площадь
минимального из наиболее дырявых кусков. Если нет кусков с дырами, выходной
файл должен содержать ноль.
<br><br>
<b>Примеры</b>
<pre><b>Ввод 1</b>
9 5
.********
.*......*
.*..**..*
.*......*
.********
<b>Вывод 1</b>
22
</pre>

</body>
</html>
